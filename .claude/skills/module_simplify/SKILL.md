# Simplify Skill

## 触发方式

用户输入 `/simplify <功能名>` 时触发此技能。

参数 `<功能名>` 是目标功能模块的自然语言描述，例如：
- `避障` — NMPC 局部避障
- `姿态控制` — 姿态 PID 控制器
- `路径规划` — A* / 多段路径规划
- `位置控制` — 位置控制器
- `状态估计` — 卡尔曼滤波器
- `任务管理` — 航线任务状态机

## 描述

分析指定模块的代码，在保证飞行速度、姿态、稳定性、避障能力等不退化的前提下，从两个维度进行精简：
1. **符号级**：识别并移除未使用的函数、字段、配置项等死代码
2. **算法级**：梳理算法流程，识别并精简冗余的算法步骤、重复计算、过度设计的机制

## 阶段一：分析（只读，不改代码）

### 1. 定位并读取目标文件

根据功能名在 `Source/uav_simulator/` 下搜索相关源码：
- 用 Glob 按文件名模糊匹配，用 Grep 按类名/关键词定位
- 读取匹配到的所有 .h 和 .cpp，建立完整理解
- 列出本次分析的文件清单（含行数），供用户确认范围是否正确

### 2. 交叉引用扫描（符号级）

对目标文件中的每个 public/protected 函数、结构体字段、配置项，在整个项目中搜索调用点：
- `Grep` 搜索函数名/字段名
- 记录每个符号的外部消费者数量

### 3. 算法流程分析（算法级）

对每个核心算法函数，绘制数据流并逐步审查：

#### 3.1 数据流追踪

对每个函数体内的主要计算步骤，记录：
- 输入来源（参数、成员变量、外部调用）
- 计算过程
- 输出去向（返回值、写入成员变量、传递给下游）

标记出"计算了但结果未被后续步骤或外部消费"的中间量。

#### 3.2 冗余计算识别

检查以下模式：

| 模式 | 说明 | 示例 |
|------|------|------|
| 重复遍历 | 同一数据集被多次遍历，可合并为一次 | 先遍历求 MinDist，再遍历算代价，可合并 |
| 冗余中间结果 | 计算了中间值但仅用于日志或从未使用 | 计算 SaturationRatio 仅用于日志输出 |
| 等价替代 | 复杂计算可用更简单的等价形式替代 | 多步条件判断可合并为单个表达式 |
| 硬编码调试残留 | 使用硬编码常量的调试计算，不具通用性 | 用固定坐标计算偏差而非用实际参考点 |

#### 3.3 过度设计识别

检查以下模式：

| 模式 | 说明 | 判定方法 |
|------|------|---------|
| 过度状态机 | 多个状态变量 + 计数器 + 冷却期实现的功能，可用更简单的机制替代 | 分析状态转换图，检查是否存在可合并的状态 |
| 过度平滑/滤波 | EMA、滞后等平滑机制，但输入信号本身已足够稳定 | 对比基线日志中平滑前后的值变化幅度 |
| 多层防护叠加 | 多个独立机制保护同一个不变量，部分机制是冗余的 | 逐个禁用（仿真验证），确认哪些是必要的 |
| 不必要的通用化 | 为假设的未来需求预留的泛化逻辑，当前只有一种使用场景 | 检查是否只有单一调用路径 |

#### 3.4 算法简化方案

对每个识别出的冗余项，设计具体的简化方案：
- 合并方案：将多次遍历合并为一次，减少计算量
- 内联方案：将仅被调用一次的辅助计算内联到调用点
- 替代方案：用更简单的等价实现替换复杂逻辑
- 移除方案：直接删除无效果的计算步骤

每个方案必须说明：
- 改动前后的行为差异（应为"无差异"或"仅影响日志/可视化"）
- 预估减少的代码行数
- 风险等级（低/中/高）及理由

### 4. 运行仿真采集基线日志

- Windows: `cmd //c "Script\\sim.bat 120"`
- macOS/Linux: `bash Script/sim.sh 120`
- 读取 `Logs/uav.log`，记录关键指标作为基线：
  - 巡航速度范围
  - Stuck 触发次数和类型
  - NeedsCorrection 状态变化次数
  - 跟踪误差（实际轨迹与期望轨迹的偏差，应 ≤ 3m）
  - 航线是否完成

### 5. 逐项评估可简化性

综合符号级和算法级分析结果，对每个候选项判定：

**符号级 — 可移除：**

| 类别 | 判定标准 | 动作 |
|------|---------|------|
| 内部死代码 | private 函数/变量，内部计算结果无人消费，且不属于公共接口 | 移除 |
| 被覆盖的逻辑 | 计算结果总是被下游覆盖，实际是死代码 | 移除 |
| 从未触发的检测器 | 基线日志中从未出现，且触发条件是其他检测器的严格子集 | 移除 |
| 废弃且已被替代的内部字段 | 有新机制完全替代，字段从未被读取（仅被写入） | 移除 |

**算法级 — 可简化：**

| 类别 | 判定标准 | 动作 |
|------|---------|------|
| 重复遍历 | 同一数据集被多次遍历且可合并，合并后行为等价 | 合并 |
| 冗余中间计算 | 计算结果仅用于日志或完全未使用，移除后不影响控制输出 | 移除 |
| 可简化的多层防护 | 多个机制保护同一不变量，仿真验证后确认部分冗余 | 移除冗余层 |
| 过度状态机 | 状态变量/计数器/冷却期可合并或用更简单机制替代 | 简化 |
| 硬编码调试残留 | 使用硬编码常量的调试计算，已有通用替代 | 移除或替换 |
| 不必要的通用化 | 仅有单一调用路径的泛化逻辑 | 特化 |

**不可简化：**

| 类别 | 判定标准 | 动作 |
|------|---------|------|
| 公共接口 | public/protected 的 getter、setter、BlueprintCallable 函数 | 保留 |
| 有活跃消费者的逻辑 | 被外部模块、可视化、测试依赖 | 保留 |
| 日志中活跃触发的检测器 | 基线日志中实际触发过 | 保留 |
| 配置项 (UPROPERTY) | 可通过编辑器/蓝图调整的参数，除非关联逻辑已被完全移除 | 保留 |
| 影响控制输出的算法步骤 | 移除后仿真指标退化 | 保留 |
| 注释掉的代码 | 可能是临时注释或调试用途 | 保留 |

### 6. 输出简化计划

以结构化格式输出计划，分两部分：

**Part A — 符号级清理：**
- 每个移除项的原因、涉及的文件和行号、具体移除内容

**Part B — 算法级精简：**
- 每个简化项的当前实现概述、问题分析、简化方案、风险等级
- 改动前后的行为差异说明

**通用：**
- 明确列出"不动的部分"及保留理由
- 预估总行数变化
- 需要适配的测试

**在此处暂停，等待用户确认后再进入阶段二。**

## 阶段二：实施

### 7. 逐项执行代码修改

按计划逐项修改，符号级清理和算法级精简交替进行：
- 每项修改后立即检查括号匹配和语法完整性
- 算法级修改需特别注意：修改后的数据流是否完整，是否有遗漏的消费者

### 8. 适配测试

- 移除依赖已删除功能的测试用例
- 确保剩余测试的断言不引用已移除的字段/配置项

### 9. 编译验证

- Windows: `cmd //c "Script\\build.bat"`
- macOS/Linux: `bash Script/build.sh`
- 编译失败 → 读取错误 → 修复 → 重新编译

### 10. 单元测试

- Windows: `cmd //c "Script\\test.bat"`
- macOS/Linux: `bash Script/test.sh`
- 对比改动前后的通过率，确认无新增失败

### 11. 仿真回归验证

- Windows: `cmd //c "Script\\sim.bat 120"`
- macOS/Linux: `bash Script/sim.sh 120`
- 读取 `Logs/uav.log`，与阶段一基线对比：
  - 巡航速度无显著下降
  - Stuck 检测仍正常工作
  - 避障行为无退化
  - 轨迹跟踪误差无显著增大（仍 ≤ 3m）
  - 航线正常完成
- 发现退化 → 回滚相关改动 → 重新编译验证

### 12. 输出总结

简要说明移除了什么、减少了多少行、验证结果。

## 约束

### 流程约束
- 阶段一（分析）完成后必须暂停等待用户确认，不得直接进入实施
- 不要主动提交代码

### 符号级约束
- 不要移除公共接口：public/protected 的 getter、setter、BlueprintCallable 函数是模块的职责边界，即使当前无调用点也必须保留
- 不要移除有活跃外部消费者的逻辑
- 不要移除日志中实际触发过的检测器

### 算法级约束
- 算法简化必须保证控制输出等价：简化前后，相同输入产生相同的控制量（OptimalAcceleration、MotorThrusts 等）
- 允许简化仅影响日志/可视化输出的中间计算，但需在计划中明确标注
- 合并遍历时必须验证合并后的计算顺序不影响结果（注意浮点累加顺序敏感性）
- 对"多层防护叠加"类简化，必须通过仿真验证确认移除的层确实冗余，不能仅凭代码分析判定

### 通用约束
- 对拿不准的项，宁可保留也不要冒险移除
